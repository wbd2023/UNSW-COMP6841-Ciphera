// Implements an in-memory HTTP relay for prekey bundles and encrypted messages.
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"ciphera/internal/domain"
)

// state holds registered prekey bundles and per-user message queues.
type state struct {
	mu      sync.Mutex
	bundles map[string]domain.PrekeyBundle
	queues  map[string][]domain.Envelope
}

// newState initialises an empty relay state.
func newState() *state {
	return &state{
		bundles: make(map[string]domain.PrekeyBundle),
		queues:  make(map[string][]domain.Envelope),
	}
}

func main() {
	s := newState()
	mux := http.NewServeMux()

	// Register HTTP endpoints.
	mux.HandleFunc("/register", s.handleRegister) // POST /register
	mux.HandleFunc("/prekey/", s.handleGetPrekey) // GET  /prekey/{username}
	mux.HandleFunc("/msg/", s.handleMsg)          // POST /msg/{user}, GET /msg/{user}, POST /msg/{user}/ack

	addr := ":8080"
	log.Printf("Relay listening on http://%s", addr)
	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("Relay failed: %v", err)
	}
}

// handleRegister stores an incoming PrekeyBundle (POST /register).
func (s *state) handleRegister(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var bundle domain.PrekeyBundle
	if err := json.NewDecoder(r.Body).Decode(&bundle); err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}
	if bundle.Username == "" {
		http.Error(w, "username required", http.StatusBadRequest)
		return
	}

	s.mu.Lock()
	s.bundles[bundle.Username] = bundle
	s.mu.Unlock()

	w.WriteHeader(http.StatusNoContent)
}

// handleGetPrekey returns a stored PrekeyBundle (GET /prekey/{username}).
func (s *state) handleGetPrekey(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	username := strings.TrimPrefix(r.URL.Path, "/prekey/")
	if username == "" {
		http.Error(w, "username required", http.StatusBadRequest)
		return
	}

	s.mu.Lock()
	bundle, ok := s.bundles[username]
	s.mu.Unlock()
	if !ok {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}

	writeJSON(w, bundle)
}

// handleMsg handles three routes under /msg/:
//   - POST /msg/{user}         – enqueue a new Envelope
//   - GET  /msg/{user}?limit=N – fetch up to N queued Envelopes
//   - POST /msg/{user}/ack     – acknowledge and drop N messages
func (s *state) handleMsg(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/msg/")
	if path == "" {
		http.Error(w, "user required", http.StatusBadRequest)
		return
	}

	// Acknowledgement: POST /msg/{user}/ack { "count": N }
	if strings.HasSuffix(path, "/ack") && r.Method == http.MethodPost {
		user := strings.TrimSuffix(path, "/ack")
		var ack struct {
			Count int `json:"count"`
		}
		if err := json.NewDecoder(r.Body).Decode(&ack); err != nil || ack.Count < 0 {
			http.Error(w, "bad request", http.StatusBadRequest)
			return
		}

		s.mu.Lock()
		queue := s.queues[user]
		if ack.Count > len(queue) {
			ack.Count = len(queue)
		}
		s.queues[user] = queue[ack.Count:]
		s.mu.Unlock()

		w.WriteHeader(http.StatusNoContent)
		return
	}

	switch r.Method {
	case http.MethodPost:
		// Enqueue new message: POST /msg/{user}
		user := path
		var env domain.Envelope
		if err := json.NewDecoder(r.Body).Decode(&env); err != nil {
			http.Error(w, "bad request", http.StatusBadRequest)
			return
		}
		// Enforce explicit recipient field
		if env.To == "" {
			http.Error(w, "recipient required", http.StatusBadRequest)
			return
		}
		// If sender omitted timestamp, assign now
		if env.Timestamp == 0 {
			env.Timestamp = time.Now().Unix()
		}

		s.mu.Lock()
		s.queues[user] = append(s.queues[user], env)
		s.mu.Unlock()

		w.WriteHeader(http.StatusNoContent)

	case http.MethodGet:
		// Fetch messages: GET /msg/{user}?limit=N
		user := path
		limit, err := parseLimit(r.URL.Query().Get("limit"))
		if err != nil {
			http.Error(w, "bad limit", http.StatusBadRequest)
			return
		}

		s.mu.Lock()
		queue := s.queues[user]
		s.mu.Unlock()

		if limit == 0 || limit > len(queue) {
			limit = len(queue)
		}
		writeJSON(w, queue[:limit])

	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// parseLimit parses the optional "limit" query parameter.
func parseLimit(v string) (int, error) {
	if v == "" {
		return 0, nil
	}
	n, err := strconv.Atoi(v)
	if err != nil || n < 0 {
		return 0, fmt.Errorf("invalid limit")
	}
	return n, nil
}

// writeJSON encodes v as JSON with no HTML escaping.
func writeJSON(w http.ResponseWriter, v any) {
	w.Header().Set("Content-Type", "application/json")
	enc := json.NewEncoder(w)
	enc.SetEscapeHTML(false)
	if err := enc.Encode(v); err != nil {
		http.Error(w, fmt.Sprintf("encode error: %v", err), http.StatusInternalServerError)
	}
}
